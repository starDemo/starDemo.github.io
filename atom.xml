<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stardemo.github.io</id>
    <title>Zone</title>
    <updated>2021-04-13T02:53:37.861Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stardemo.github.io"/>
    <link rel="self" href="https://stardemo.github.io/atom.xml"/>
    <subtitle>一个技术爱好者的备忘录</subtitle>
    <logo>https://stardemo.github.io/images/avatar.png</logo>
    <icon>https://stardemo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zone</rights>
    <entry>
        <title type="html"><![CDATA[MacOS 下使用nvm管理node环境]]></title>
        <id>https://stardemo.github.io/post/macos-xia-shi-yong-nvm-guan-li-node-huan-jing/</id>
        <link href="https://stardemo.github.io/post/macos-xia-shi-yong-nvm-guan-li-node-huan-jing/">
        </link>
        <updated>2021-04-13T02:34:06.000Z</updated>
        <summary type="html"><![CDATA[<p>node版本变化有些快，需要切换不同版本构建项目，使用nvm管理node是一个比较成熟的方案。</p>
]]></summary>
        <content type="html"><![CDATA[<p>node版本变化有些快，需要切换不同版本构建项目，使用nvm管理node是一个比较成熟的方案。</p>
<!-- more -->
<h2 id="1-安装nvm">1. 安装nvm</h2>
<h3 id="11-macos">1.1 MacOS</h3>
<ul>
<li>brew安装</li>
</ul>
<pre><code class="language-shell">brew install nvm 
</code></pre>
<ul>
<li>官方脚本</li>
</ul>
<pre><code class="language-shell">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
</code></pre>
<h3 id="12-linux">1.2 Linux</h3>
<pre><code class="language-shell">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
</code></pre>
<h3 id="13-安装注意事项">1.3 安装注意事项</h3>
<pre><code>==&gt; Caveats
Please note that upstream has asked us to make explicit managing
nvm via Homebrew is unsupported by them and you should check any
problems against the standard nvm install method prior to reporting.

You should create NVM's working directory if it doesn't exist:

  mkdir ~/.nvm

Add the following to ~/.zshrc or your desired shell
configuration file:

  export NVM_DIR=&quot;$HOME/.nvm&quot;
  [ -s &quot;/opt/homebrew/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/nvm.sh&quot;  # This loads nvm
  [ -s &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot;  # This loads nvm bash_completion

You can set $NVM_DIR to any location, but leaving it unchanged from
/opt/homebrew/opt/nvm will destroy any nvm-installed Node installations
upon upgrade/reinstall.

Type `nvm help` for further information.

</code></pre>
<ul>
<li>创建nvm目录</li>
</ul>
<pre><code class="language-shell">mkdir ~/.nvm
</code></pre>
<ul>
<li>处理<code>~/.zshrc</code>或者<code>~/.bashrc</code>（此处zsh举例）</li>
</ul>
<pre><code class="language-shell">  export NVM_DIR=&quot;$HOME/.nvm&quot;
  [ -s &quot;/opt/homebrew/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/nvm.sh&quot;  # This loads nvm
  [ -s &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot;  # This loads nvm bash_completion
</code></pre>
<h2 id="2-配置镜像加速">2. 配置镜像加速</h2>
<h3 id="21-nvm加速">2.1 nvm加速</h3>
<p>需要设置环境变量<code>NVM_NODEJS_ORG_MIRROR</code></p>
<pre><code class="language-shell"># 临时设置
export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node
# 配置上述命令到bashrc/zshrc中保持生效
</code></pre>
<h3 id="22-npm加速">2.2 npm加速</h3>
<pre><code class="language-shell"># 查看当前registry
npm config -g get registry
# 设置registry
npm config -g set registry https://registry.npm.taobao.org
</code></pre>
<h3 id="23-yarn配置">2.3 yarn配置</h3>
<pre><code class="language-shell"># 安装yarn
npm install -g yarn
# 查看yarn registry
yarn config get registry
# 设置yarn registry
yarn config set registry http://registry.npm.taobao.org/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git HTTP+SSH 代理配置]]></title>
        <id>https://stardemo.github.io/post/git-httpssh-dai-li-pei-zhi/</id>
        <link href="https://stardemo.github.io/post/git-httpssh-dai-li-pei-zhi/">
        </link>
        <updated>2021-04-07T15:57:20.000Z</updated>
        <summary type="html"><![CDATA[<p>github访问日益困难,配置git服务代理以快速clone代码🐶</p>
]]></summary>
        <content type="html"><![CDATA[<p>github访问日益困难,配置git服务代理以快速clone代码🐶</p>
<!-- more -->
<p><em><strong>技术方案转载于<a href="http://www.chenhe.cc/p/406">http://www.chenhe.cc/p/406</a></strong></em></p>
<h2 id="http-代理">HTTP 代理</h2>
<h3 id="配置全局代理">配置全局代理</h3>
<pre><code class="language-shell"># HTTP 代理
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy http://127.0.0.1:7890

# Socks5 代理
git config --global http.proxy socks5://127.0.0.1:7890
git config --global https.proxy socks5://127.0.0.1:7890
</code></pre>
<p>注意这里的<code>socks5</code>仅仅是代理使用的协议，它依然是针对 http 设置的，所以仅对 http 协议的仓库有效。使用 <code>git@xxx</code>这种 ssh 连接的不会使用代理。</p>
<h3 id="分域名设置代理">分域名设置代理</h3>
<pre><code class="language-shell">git config --global http.https://github.com.proxy http://127.0.0.1:7890
git config --global https.https://github.com.proxy https://127.0.0.1:7890
</code></pre>
<h2 id="ssh-代理">SSH 代理</h2>
<p>SSH 代理需要在密钥目录 (<code>~/.ssh</code>) (Windows 下是 <code>C:\Users\{UserName}\.ssh</code>) 新建一个 config 文件，没有后缀名。</p>
<h3 id="linuxmacos-系统写入以下配置">Linux/MacOS 系统写入以下配置：</h3>
<pre><code class="language-shell"># 需要 netcat
Host github.com
  User git
  Port 22
  Hostname github.com
  TCPKeepAlive yes
  ProxyCommand nc -v -x 127.0.0.1:1080 %h %p
</code></pre>
<h3 id="windows系统配置">Windows系统配置</h3>
<p>需要额外安装<code>connect.exe</code>程序,如果找不到 connect 命令那么指定其绝对路径，一般在 git 安装目录下 \mingw64\bin\connect.exe。</p>
<pre><code class="language-shell">Host github.com
  User git
  Port 22
  Hostname github.com
  TCPKeepAlive yes
  # -S 为 socks, -H 为 HTTP
  ProxyCommand connect -S 127.0.0.1:1080 %h %p
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux下使用curl查看http请求各阶段耗时]]></title>
        <id>https://stardemo.github.io/post/linux-xia-shi-yong-curl-cha-kan-http-qing-qiu-ge-jie-duan-hao-shi/</id>
        <link href="https://stardemo.github.io/post/linux-xia-shi-yong-curl-cha-kan-http-qing-qiu-ge-jie-duan-hao-shi/">
        </link>
        <updated>2021-04-07T15:50:42.000Z</updated>
        <summary type="html"><![CDATA[<p>HTTP接口在业务中速度较慢，使用curl进行排查</p>
]]></summary>
        <content type="html"><![CDATA[<p>HTTP接口在业务中速度较慢，使用curl进行排查</p>
<!-- more -->
<h2 id="1-准备文件模版curltxt">1. 准备文件模版（curl.txt）</h2>
<pre><code class="language-shell">\n
            time_namelookup:  %{time_namelookup}\n
               time_connect:  %{time_connect}\n
            time_appconnect:  %{time_appconnect}\n
           time_pretransfer:  %{time_pretransfer}\n
              time_redirect:  %{time_redirect}\n
         time_starttransfer:  %{time_starttransfer}\n
                            ----------\n
                 time_total:  %{time_total}\n
\n
</code></pre>
<h2 id="2-使用curl带以下参数请求">2. 使用curl带以下参数请求</h2>
<pre><code class="language-shell">curl -w &quot;@curl.txt&quot; -o /dev/null -s https://api.example.com
</code></pre>
<p>结果</p>
<pre><code>[@ ~]# curl -w &quot;@curl&quot; -o /dev/null -s https://api.example.com

            time_namelookup:  0.004
               time_connect:  0.014
            time_appconnect:  0.141
           time_pretransfer:  0.141
              time_redirect:  0.000
         time_starttransfer:  0.153
                            ----------
                 time_total:  0.165
</code></pre>
<h2 id="3-参数说明">3. 参数说明</h2>
<ul>
<li>NAMELOOKUP：从开始计算，域名解析完成的耗时</li>
</ul>
<p>CURLINFO_NAMELOOKUP_TIME. The time it took from the start until the name resolving was completed.</p>
<ul>
<li>CONNECT：从开始计算，TCP建立完成的耗时</li>
</ul>
<p>CURLINFO_CONNECT_TIME. The time it took from the start until the connect to the remote host (or proxy) was completed.</p>
<ul>
<li>APPCONNECT：从开始计算，应用层（SSL，在TCP之上的应用层）连接/握手完成的耗时</li>
</ul>
<p>CURLINFO_APPCONNECT_TIME. The time it took from the start until the SSL connect/handshake with the remote host was completed. (Added in in 7.19.0)</p>
<ul>
<li>PRETRANSFER：从开始计算，准备开始传输数据的耗时</li>
</ul>
<p>CURLINFO_PRETRANSFER_TIME. The time it took from the start until the file transfer is just about to begin. This includes all pre-transfer commands and negotiations that are specific to the particular protocol(s) involved.</p>
<ul>
<li>STARTTRANSFER：从开始计算，开始传输数据的耗时（libcurl接收到第一个字节）</li>
</ul>
<p>CURLINFO_STARTTRANSFER_TIME. The time it took from the start until the first byte is received by libcurl.</p>
<ul>
<li>TOTAL：总的耗时</li>
</ul>
<p>CURLINFO_TOTAL_TIME. Total time of the previous request.</p>
<ul>
<li>REDIRECT：整个过程重定向的耗时，如果整个过程没有重定向，这个时间为0</li>
</ul>
<p><em><strong>文章来源于互联网,原地址<a href="https://www.cnblogs.com/lnlvinso/p/9775484.html">https://www.cnblogs.com/lnlvinso/p/9775484.html</a></strong></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在macOS下启用CGO_ENABLED的交叉编译]]></title>
        <id>https://stardemo.github.io/post/zai-macos-xia-qi-yong-cgo_enabled-de-jiao-cha-bian-yi/</id>
        <link href="https://stardemo.github.io/post/zai-macos-xia-qi-yong-cgo_enabled-de-jiao-cha-bian-yi/">
        </link>
        <updated>2021-03-26T12:15:00.000Z</updated>
        <summary type="html"><![CDATA[<p>go 启用CGO_ENABLED遇到报错的解决方案<br>
<code>gcc_libinit_windows.c:7:10: fatal error: 'windows.h' file not found</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>go 启用CGO_ENABLED遇到报错的解决方案<br>
<code>gcc_libinit_windows.c:7:10: fatal error: 'windows.h' file not found</code></p>
<!-- more -->
<h2 id="在macos下启用cgo_enabled的交叉编译">在macOS下启用CGO_ENABLED的交叉编译</h2>
<p>在启用CGO_ENABLED的情况下，尝试使用下面命令进行Windows平台的交叉编译：</p>
<pre><code class="language-shell">$ CGO_ENABLED=1 GOOS=windows GOARCH=386 go build -x -v -ldflags &quot;-s -w&quot;
</code></pre>
<p>出现错误如下：</p>
<pre><code class="language-shell"># runtime/cgo
gcc_libinit_windows.c:7:10: fatal error: 'windows.h' file not found
</code></pre>
<h2 id="安装mingw-w64">安装mingw-w64</h2>
<pre><code class="language-shell">$ brew install mingw-w64
==&gt; Downloading https://homebrew.bintray.com/bottles/isl-0.22.1.big_sur.bottle.tar.gz
==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/15376fb7aff7adec3786e6a31ec9b5cad585fd01ecbd5c4744ef9461b10965ff?response-content-disposition=attachment%3Bfilename%3D%22isl-0.22.1.big_sur.bottle.tar.gz%22&amp;Policy=eyJTdGF0Z
######################################################################## 100.0%
==&gt; Downloading https://homebrew.bintray.com/bottles/mpfr-4.1.0.big_sur.bottle.tar.gz
==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/1e8eb0326f62d3461d420d98af6fc088daca481cae89fd77a75b420d2e76d776?response-content-disposition=attachment%3Bfilename%3D%22mpfr-4.1.0.big_sur.bottle.tar.gz%22&amp;Policy=eyJTdGF0Z
######################################################################## 100.0%
==&gt; Downloading https://homebrew.bintray.com/bottles/libmpc-1.2.1.big_sur.bottle.tar.gz
######################################################################## 100.0%
==&gt; Downloading https://homebrew.bintray.com/bottles/mingw-w64-8.0.0.catalina.bottle.tar.gz
==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/d294bc0e960294bf573b9da364a8d95a06a257aec8f388c16e2b975ed8e4410c?response-content-disposition=attachment%3Bfilename%3D%22mingw-w64-8.0.0.catalina.bottle.tar.gz%22&amp;Policy=eyJ
######################################################################## 100.0%
==&gt; Installing dependencies for mingw-w64: isl, mpfr and libmpc
==&gt; Installing mingw-w64 dependency: isl
==&gt; Pouring isl-0.22.1.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/isl/0.22.1: 72 files, 4.9MB
==&gt; Installing mingw-w64 dependency: mpfr
==&gt; Pouring mpfr-4.1.0.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/mpfr/4.1.0: 30 files, 5.2MB
==&gt; Installing mingw-w64 dependency: libmpc
==&gt; Pouring libmpc-1.2.1.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/libmpc/1.2.1: 13 files, 425.0KB
==&gt; Installing mingw-w64
==&gt; Pouring mingw-w64-8.0.0.catalina.bottle.tar.gz
🍺  /usr/local/Cellar/mingw-w64/8.0.0: 7,402 files, 854.6MB
$ which x86_64-w64-mingw32-gcc
/usr/local/bin/x86_64-w64-mingw32-gcc
</code></pre>
<h2 id="编译x64">编译x64</h2>
<h3 id="可执行文件">可执行文件</h3>
<pre><code class="language-shell">$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -x -v -ldflags &quot;-s -w&quot; -o app.exe
</code></pre>
<h3 id="静态库">静态库</h3>
<pre><code class="language-shell">$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -buildmode=c-archive -x -v -ldflags &quot;-s -w&quot; -o bin app.go
</code></pre>
<h3 id="动态库">动态库</h3>
<p>将<code>-buildmode=c-archive</code>改为<code>-buildmode=c-shared</code>即可</p>
<p><em><strong>转载资料 出处:<a href="https://www.dllhook.com/post/244.html">https://www.dllhook.com/post/244.html</a></strong></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kubernetes暴露信息给Pod]]></title>
        <id>https://stardemo.github.io/post/kubernetes-bao-lu-xin-xi-gei-pod/</id>
        <link href="https://stardemo.github.io/post/kubernetes-bao-lu-xin-xi-gei-pod/">
        </link>
        <updated>2021-02-06T08:53:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="capabilities-of-the-downward-api">Capabilities of the Downward API</h3>
<h4 id="feildref即可以暴露的pod定义中的项目">feildRef，即可以暴露的pod定义中的项目：</h4>
<pre><code>spec.nodeName - the node’s name
status.hostIP - the node’s IP
metadata.name - the pod’s name
metadata.namespace - the pod’s namespace
status.podIP - the pod’s IP address
spec.serviceAccountName - the pod’s service account name
metadata.uid - the pod’s UID
metadata.labels['&lt;KEY&gt;'] - the value of the pod’s label &lt;KEY&gt; (for example, metadata.labels['mylabel']); available in Kubernetes 1.9+
metadata.annotations['&lt;KEY&gt;'] - the value of the pod’s annotation &lt;KEY&gt; (for example, metadata.annotations['myannotation']); available in Kubernetes 1.9+
</code></pre>
<h4 id="resourcefieldref即可以暴露的container定义中的项目">resourceFieldRef，即可以暴露的container定义中的项目：</h4>
<ul>
<li>A Container’s CPU limit</li>
<li>A Container’s CPU request</li>
<li>A Container’s memory limit</li>
<li>A Container’s memory request</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LDAP使用记录]]></title>
        <id>https://stardemo.github.io/post/ldap-shi-yong-ji-lu/</id>
        <link href="https://stardemo.github.io/post/ldap-shi-yong-ji-lu/">
        </link>
        <updated>2020-12-11T07:00:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="rancher访问ldap的默认规则">Rancher访问LDAP的默认规则</h2>
<h3 id="用户">用户</h3>
<pre><code>搜索起点: ou=Users,dc=thecover,dc=cn
对象分类: inetOrgPerson
登录字段: uid
名称字段: cn
搜索字段: uid|sn|givenName
启用字段:
禁用位掩码: 0
</code></pre>
<h3 id="用户组">用户组</h3>
<pre><code>搜索起点: ou=Groups,dc=thecover,dc=cn
对象分类: groupOfNames
名称字段: cn
搜索字段: cn
</code></pre>
<h3 id="创建只读用户">创建只读用户</h3>
<ul>
<li>创建用户（可以用管理工具创建同objectClass的用户）</li>
</ul>
<pre><code>#密码
LDAP_READONLY_USER_PW='密码'
#Base DN
LDAP_BASE_DN='dc=thecover,dc=cn'
cat &lt;&lt;EOF &gt; ./readOnly.ldif
dn: cn=readonly,${LDAP_BASE_DN}
cn: readonly
objectClass: simpleSecurityObject
objectClass: organizationalRole
description: LDAP read only user
userPassword: ${LDAP_READONLY_USER_PW}
EOF
</code></pre>
<p>命令行增加用户</p>
<pre><code>ldapadd -x -D cn=Manager,dc=okcoin,dc=com -w '密码' -f ./readOnly.ldif
</code></pre>
<ul>
<li>配置权限</li>
</ul>
<pre><code>LDAP_BASE_DN='dc=thecover,dc=cn'
cat &lt;&lt;EOF &gt; readonly-user-acl.ldif
dn: olcDatabase={1}hdb,cn=config
changetype: modify
delete: olcAccess
-
add: olcAccess
olcAccess: {0}to attrs=userPassword,shadowLastChange 
 by dn=&quot;cn=admin,dc=thecover,dc=cn&quot; write 
 by anonymous auth 
 by self write 
 by dn=&quot;cn=readonly,dc=thecover,dc=cn&quot; read 
 by * none
olcAccess: {1}to dn.base=&quot;&quot; by * read
olcAccess: {2}to * by dn=&quot;cn=Manager,dc=thecover,dc=cn&quot; write by * read
EOF
</code></pre>
<pre><code>ldapmodify -Y EXTERNAL -H ldapi:/// -f readonly-user-acl.ldif
</code></pre>
<ul>
<li>备注<br>
配置权限时需要使用</li>
</ul>
<pre><code>slapcat -b cn=config
</code></pre>
<p>定位<code>olcDatabase</code> <code>config</code>的位置</p>
<h2 id="ldap增加memberof属性">Ldap增加memberOf属性</h2>
<p>https://www.linuxprobe.com/enable-memberof-openldap.html<br>
https://kifarunix.com/how-to-create-openldap-member-groups/</p>
<h2 id="配置缓存">配置缓存</h2>
<h3 id="查询缓存配置">查询缓存配置</h3>
<pre><code class="language-shell">ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b cn=config 'olcDatabase={0}mdb' olcDbindex
</code></pre>
<h3 id="删除旧配置">删除旧配置</h3>
<pre><code class="language-shell">cat &gt;&gt; del-1mdb-index.ldif &lt;&lt; EOF
dn: olcDatabase={1}mdb, cn=config
changetype:modify
delete: olcDbIndex
olcDbIndex: uid eq
EOF
 ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f del-1mdb-index.ldif
</code></pre>
<h3 id="新增配置">新增配置</h3>
<pre><code class="language-shell">cat &gt;&gt; mdb-index.ldif &lt;&lt; EOF
dn: olcDatabase={1}mdb, cn=config
changetype:modify
add:olcDbIndex
olcDbIndex: uid pres,eq,sub
EOF
ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f mdb-index.ldif
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阿里云K8s实践笔记]]></title>
        <id>https://stardemo.github.io/post/a-li-yun-k8s-zui-jia-shi-jian-bi-ji/</id>
        <link href="https://stardemo.github.io/post/a-li-yun-k8s-zui-jia-shi-jian-bi-ji/">
        </link>
        <updated>2020-09-16T03:36:16.000Z</updated>
        <summary type="html"><![CDATA[<p>记录使用阿里云ACK容器服务以及阿里云的各服务的总结笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录使用阿里云ACK容器服务以及阿里云的各服务的总结笔记</p>
<!-- more -->
<h2 id="1-配置阿里云slb到集群的ingress">1. 配置阿里云SLB到集群的Ingress</h2>
<h3 id="11-同时使用私网slb与公网slb配合">1.1 同时使用私网SLB与公网SLB配合</h3>
<p><em>对于一些特殊场景，您期望容器集群内的服务既能允许公网访问，同时又希望能被同一个VPC下的其他服务直接访问（不经过公网）。您只需额外部署一个kube-system/nginx-ingress-lb-intranet服务。</em></p>
<p>使用阿里云创建的容器集群默认已经创建了一个绑定到公网的SLB，位于<code>kube-system</code>下。创建一个符合期望配置的内网SLB实例，新增一个Service描述，使集群自动绑定监听到SLB。</p>
<p>配置模版</p>
<pre><code class="language-yaml"># intranet nginx ingress slb service
apiVersion: v1
kind: Service
metadata:
 # 这里服务取名为nginx-ingress-lb-intranet
 name: nginx-ingress-lb-intranet
 namespace: kube-system
 labels:
   app: nginx-ingress-lb-intranet
 annotations:
   # 指明SLB实例地址类型为私网类型
   service.beta.kubernetes.io/alicloud-loadbalancer-address-type: intranet
   # 修改为您的私网SLB实例ID
   service.beta.kubernetes.io/alicloud-loadbalancer-id: &lt;YOUR_INTRANET_SLB_ID&gt;
   # 是否自动创建SLB端口监听（会覆写已有端口监听），也可手动创建端口监听
   service.beta.kubernetes.io/alicloud-loadbalancer-force-override-listeners: 'true'
spec:
 type: LoadBalancer
 # route traffic to other nodes
 externalTrafficPolicy: &quot;Cluster&quot;
 ports:
 - port: 80
   name: http
   targetPort: 80
 - port: 443
   name: https
   targetPort: 443
 selector:
   # select app=ingress-nginx pods
   app: ingress-nginx
</code></pre>
<p>创建服务之后通过如下命令,查看svc状态</p>
<pre><code class="language-shell"> kubectl -n kube-system get svc | grep nginx-ingress-lb
</code></pre>
<h2 id="2-coredns的特殊用法">2. CoreDNS的特殊用法</h2>
<h3 id="21-coredns拦截域名解析">2.1 CoreDNS拦截域名解析</h3>
<p>在内网多个集群的场景下，有些域名需要解析到内网避免出现公网流量，之前处理方案有如下几种:</p>
<ul>
<li>在VPC内网内自建一个DNS服务器，将所有服务器的DNS指向自建的DNS服务器
<ul>
<li>问题: 需要考虑到DNS的高可用以及故障容灾难</li>
<li>优势: 集中化,便于统一维护管理更新</li>
</ul>
</li>
<li>在主机配置Hosts文件
<ul>
<li>问题: 主机较多，维护成本上涨</li>
<li>优势: 操作简单，技术成本较低</li>
</ul>
</li>
<li>K8s容器集群内CoreDNS</li>
</ul>
<p>Kubernetes本身具有集群DNS组件，此处使用的为CoreDNS，工作负载的DNS默认策略为<code>ClusterFirst</code>,此时Pods内程序解析DNS会优先查询集群的DNS组件，所以此时可以在集群DNS层面进行解析拦截覆盖。</p>
<p>CoreDNS的配置使用的ConfigMap,而ConfigMap支持热更新,修改ConfigMap后CoreDNS自动生效。配置如下:</p>
<pre><code>.:5353 {
cache 30
errors
health
kubernetes cluster.local in-addr.arpa ip6.arpa {
pods insecure
upstream /etc/resolv.conf
fallthrough in-addr.arpa ip6.arpa
}
loadbalance round_robin
hosts {
122.212.222.111 aaa.bbb.com
fallthrough
}
prometheus 0.0.0.0:9153
proxy . /etc/resolv.conf
reload
}
</code></pre>
<p>把需要的DNS规格写入Hosts节点下，即可进行集群层面的解析配置。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用nc检测TCP/UDP端口开放]]></title>
        <id>https://stardemo.github.io/post/shi-yong-nc-jian-ce-tcpudp-duan-kou-kai-fang/</id>
        <link href="https://stardemo.github.io/post/shi-yong-nc-jian-ce-tcpudp-duan-kou-kai-fang/">
        </link>
        <updated>2020-08-18T13:40:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="telnet-检测tcp端口">Telnet 检测TCP端口</h1>
<pre><code class="language-shell">[root@localhost ~]# telnet 127.0.0.1 8080
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
^CConnection closed by foreign host.
</code></pre>
<h1 id="nc-检测tcp端口">NC 检测TCP端口</h1>
<pre><code class="language-shell">[root@localhost ~]# nc -vz 127.0.0.1 8906
Connection to 127.0.0.1 8906 port [tcp/*] succeeded!
</code></pre>
<h1 id="nc-检测udp端口">NC 检测UDP端口</h1>
<p><code>检测udp端口的时候不会立即返回测试结果，可能需要等待几秒钟</code></p>
<pre><code class="language-shell">[root@apexsoft ~]# nc -uz 127.0.0.1 8907
Connection to 127.0.0.1 8907 port [udp/*] succeeded!
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Nginx根据UA过滤请求]]></title>
        <id>https://stardemo.github.io/post/nginx-gen-ju-ua-guo-lu-qing-qiu/</id>
        <link href="https://stardemo.github.io/post/nginx-gen-ju-ua-guo-lu-qing-qiu/">
        </link>
        <updated>2020-05-26T08:46:34.000Z</updated>
        <summary type="html"><![CDATA[<p>有需求一个系统只允许微信和钉钉访问，所以配置Nginx规则过滤UA</p>
]]></summary>
        <content type="html"><![CDATA[<p>有需求一个系统只允许微信和钉钉访问，所以配置Nginx规则过滤UA</p>
<!-- more -->
<h1 id="配置文件">配置文件</h1>
<pre><code class="language-nginx">server {
    listen       80;
    server_name  localhost;
    set $flag 0;
    if ($http_user_agent !~ &quot;MicroMessenger&quot; ){
        set $flag &quot;${flag}1&quot;;
    }
    if ( $http_user_agent !~ &quot;DingTalk&quot; ){
        set $flag &quot;${flag}2&quot;;
    }
    if ($flag = &quot;012&quot;) {
        return 403;
    }
    location / {
        root   /usr/share/nginx/html;
        index  index.html index.htm;
    }
    #error_page  404              /404.html;
    # redirect server error pages to the static page /50x.html
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
</code></pre>
<h1 id="踩过的坑">踩过的坑</h1>
<h2 id="一-nginx多条件判断">一. Nginx多条件判断</h2>
<h2 id="问题">问题</h2>
<p><em>nginx的配置中不支持if条件的逻辑与、逻辑或运算 ，并且不支持if的嵌套语法</em>*</p>
<h2 id="解法">解法</h2>
<p>定义变量,判断变量状态。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[React]React实战(1)——Ant Design Pro项目history模式下相关配置]]></title>
        <id>https://stardemo.github.io/post/reactreact-shi-zhan-1-ant-design-pro-xiang-mu-history-mo-shi-xia-xiang-guan-pei-zhi/</id>
        <link href="https://stardemo.github.io/post/reactreact-shi-zhan-1-ant-design-pro-xiang-mu-history-mo-shi-xia-xiang-guan-pei-zhi/">
        </link>
        <updated>2020-05-25T07:14:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="相关链接">相关链接</h1>
<p><a href="https://pro.ant.design/docs/deploy-cn">AntDesign文档</a></p>
<h1 id="nginx-配置文件修改">Nginx 配置文件修改</h1>
<h2 id="完整配置">完整配置</h2>
<pre><code class="language-nginx">server {
    listen       80;
    server_name  localhost;
    location / { 
    proxy_pass http://localhost:8000;
    }
  location /active {
      try_files $uri $uri/ /healthy/index.html;
  }

  location /healthy/api {
       proxy_pass   http://localhost:8888/;
  }
    error_page   500 502 503 504  /50x.html;
    location = /50x.html {
        root   /usr/share/nginx/html;
    }
}
</code></pre>
<h2 id="8000端口下nginx配置">8000端口下nginx配置</h2>
<pre><code class="language-nginx">server {
    listen  8000;
    server_name   localhost;
    location / {
        root   /usr/project/;
        try_files $uri $uri/ /index.html;  #配合react项目的history模式去除#时用到
        index index.html;
        client_max_body_size    8m;
    }
}
</code></pre>
<h2 id="配置文件说明">配置文件说明</h2>
<ul>
<li>使用try_files方式的前提是服务器安装nginx的时候需要安装相应的模块，我是通过yarn源的方式安装的，包含了所有模块，所以可以直接使用</li>
<li>80端口下根目录会指向8000端口（习惯把项目都放在8000端口下指向的project目录下），同时添加/active访问拦截指向healthy目录下index.html，同时添加/healthy/api是为了拦截接口访问</li>
<li>8000端口下root指向的是/usr/project/，此目录放置所有前端项目文件夹，一些node服务端项目也可以放进去</li>
</ul>
<h1 id="ant-design-pro项目中相关配置">Ant Design Pro项目中相关配置</h1>
<h2 id="修改config文件">修改config文件</h2>
<p>项目目录下config/config.js</p>
<pre><code class="language-javascript">export default {
  plugins,
  proxy,
  block: {
    defaultGitUrl: 'https://github.com/ant-design/pro-blocks',
  },
  hash: false, // browser 模式下为false, hash 模式下为true
  history: 'browser', // 默认是 browser ， hash
  base: '/healthy/', // browser 模式下为 /healthy/ ， hash模式下为 /
  publicPath: '/healthy/', // 模式下为 /healthy/ ， hash模式下为 ./
  targets: {
    ie: 11,
  },
  devtool: isAntDesignProPreview ? 'source-map' : false,
}
</code></pre>
<h2 id="引用外部文件">引用外部文件</h2>
<p>pages/document.ejs中引用的外部文件</p>
<pre><code class="language-html">&lt;link rel=&quot;shortcut icon&quot; href=&quot;./favicon.ico&quot;&gt;
</code></pre>
<h2 id="接口调用配置">接口调用配置</h2>
<pre><code class="language-javascript">// config/config.js配置文件
global.api = '/healthy/api'
// 调用接口页面
let response = await axios.get(`${global.api}/dtea-service/user/result?examId=${this.questionId}`);
</code></pre>
<p>为了本地项目和发布至服务器打包文件保持一致，可以把项目中本地代理修改下</p>
<pre><code class="language-javascript">const proxy = {
  '/healthy/api': {
    target: 'http://192.136.12.211:8888',
    changeOrigin: true,
    pathRewrite: {
      '^/healthy/api': '',
    },
  },
};
}
</code></pre>
<p>作者：wayne1125<br>
链接：https://www.jianshu.com/p/16de172d0d45<br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
]]></content>
    </entry>
</feed>