<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://stardemo.github.io</id>
    <title>Zone</title>
    <updated>2021-05-07T15:50:55.770Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://stardemo.github.io"/>
    <link rel="self" href="https://stardemo.github.io/atom.xml"/>
    <subtitle>一个技术爱好者的备忘录</subtitle>
    <logo>https://stardemo.github.io/images/avatar.png</logo>
    <icon>https://stardemo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zone</rights>
    <entry>
        <title type="html"><![CDATA[记录一次服务器磁盘容量不足的清理过程]]></title>
        <id>https://stardemo.github.io/post/ji-lu-yi-ci-fu-wu-qi-ci-pan-rong-liang-bu-zu-de-qing-li-guo-cheng/</id>
        <link href="https://stardemo.github.io/post/ji-lu-yi-ci-fu-wu-qi-ci-pan-rong-liang-bu-zu-de-qing-li-guo-cheng/">
        </link>
        <updated>2021-05-07T12:57:01.000Z</updated>
        <summary type="html"><![CDATA[<p>遇到了两个问题</p>
<ul>
<li><code>/var/spool/postfix/maildrop</code>产生大量文件</li>
<li>目录中文件过多导致ls命令卡住</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>遇到了两个问题</p>
<ul>
<li><code>/var/spool/postfix/maildrop</code>产生大量文件</li>
<li>目录中文件过多导致ls命令卡住</li>
</ul>
<!-- more -->
<h2 id="前因">前因</h2>
<p>收到服务器报警邮件，磁盘使用率超过百分之97，遂上线检查清理</p>
<h3 id="检查目录占用情况">检查目录占用情况</h3>
<p>笨办法，<code>du -sh *</code> 查看目录/文件大小，发现卡在<code>var</code>目录下，进入目录继续测试，发现最终卡在<code>/var/spool/postfix/maildrop</code>下，进入目录，ls 发现ls卡死，需要kil 才能恢复，<code>ls -l |wc -l</code>同样结果，遂开始研究问题。</p>
<h2 id="问题1-varspoolpostfixmaildrop产生大量文件">问题1.  <code>/var/spool/postfix/maildrop</code>产生大量文件</h2>
<p>crontab 每次执行任务后会发送邮件，接受者是在他的配置文件 “/etc/crontab” 通过 MAILTO=root’ 来设置的，默认是root。发送后的邮件就到<code>/var/spool/postfix/maildrop</code>下了。</p>
<p>如果需要邮件发送到指定邮箱，则需要配置此处。</p>
<p>继续检查发现发现服务器上有很多crontab任务，因而判断发送太多邮件到maildrop下导致文件超多。</p>
<h3 id="解决方案">解决方案</h3>
<h4 id="方案1">方案1</h4>
<pre><code>修改“/etc/crontab”
将‘MAILTO=root’替换成‘MAILTO=&quot;&quot;’修改之后没有成功，需要重启crond服务才可以
也可从在crontab（crontab -e）中最前面直接加入MAILTO=&quot;&quot;
</code></pre>
<h4 id="方案2">方案2</h4>
<p>如果是我们不关心的备注型等输出我们完全可以让其输出到 <code>/dev/null</code> 这样就不会因为发送失败到导致在<code>/var/spool/postfix/maildrop</code>下面产出什么文件。<br>
如果需要收集输出log，可在<code>crontab job</code>后增加<code>&gt;</code>定向输出<br>
例如：</p>
<pre><code class="language-shell"># 输出空
*/10 * * * * /tmp/test.sh &gt;/dev/null 2&gt;&amp;1
# 定向输出到文件
*/10 * * * * /tmp/test.sh &gt;/log/test.log 2&gt;&amp;1
</code></pre>
<h3 id="结果">结果</h3>
<p>使用<code>方案1</code>后重启crond服务，则不会产生新的文件。</p>
<h2 id="问题2-目录中文件过多导致ls命令卡住">问题2. 目录中文件过多导致ls命令卡住</h2>
<h3 id="解决方案-2">解决方案</h3>
<p>如果需要立马显示文件内容，则使用</p>
<pre><code class="language-shell">ls -1 -f 
# 删除文件
ls -1 -f | xargs rm
</code></pre>
<p>即可立马显示文件。</p>
<h3 id="问题原因">问题原因</h3>
<p>(https://www.jianshu.com/p/353a5dbcd423)[https://www.jianshu.com/p/353a5dbcd423]</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[面经] 常见面试问答整理]]></title>
        <id>https://stardemo.github.io/post/mian-jing-chang-jian-mian-shi-wen-da-zheng-li/</id>
        <link href="https://stardemo.github.io/post/mian-jing-chang-jian-mian-shi-wen-da-zheng-li/">
        </link>
        <updated>2021-04-26T14:03:05.000Z</updated>
        <summary type="html"><![CDATA[<p>收集各路面试问答，做一个记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>收集各路面试问答，做一个记录</p>
<!-- more -->
<h2 id="1-网络基础">1. 网络基础</h2>
<h3 id="11-问三次握手和四次挥手">1.1 问：三次握手和四次挥手</h3>
<p>为什么要进行三次握手：为了确认对方的发送和接收能力。</p>
<h4 id="三次握手">三次握手</h4>
<p>三次握手主要流程：</p>
<ul>
<li>一开始双方处于 <code>CLOSED</code>状态，然后服务端开始监听某个端口进入 <code>LISTEN</code> 状态</li>
<li>然后客户端主动发起连接，发送 <code>SYN</code>，然后自己变为 <code>SYN-SENT</code>，<code>seq = x</code></li>
<li>服务端收到之后，返回 <code>SYN seq = y</code> 和 <code>ACK ack = x + 1</code>（对于客户端发来的 SYN），自己变成 <code>SYN-REVD</code></li>
<li>之后客户端再次发送 <code>ACK seq = x + 1</code>,<code>ack = y + 1</code>给服务端，自己变成 <code>EASTABLISHED</code> 状态，服务端收到 <code>ACK</code>，也进入<code>ESTABLISHED</code></li>
</ul>
<p><code>SYN 需要对端确认，所以 ACK 的序列化要加一，凡是需要对端确认的，一点要消耗 TCP 报文的序列化</code></p>
<h4 id="为什么不是两次">为什么不是两次？</h4>
<p><code>无法确认客户端的接收能力。</code></p>
<p>如果首先客户端发送了 SYN 报文，但是滞留在网络中，TCP 以为丢包了，然后重传，两次握手建立了连接。<br>
等到客户端关闭连接了。但是之后这个包如果到达了服务端，那么服务端接收到了，然后发送相应的数据表，就建立了链接，但是此时客户端已经关闭连接了，所以带来了链接资源的浪费。</p>
<h4 id="为什么不是四次">为什么不是四次？</h4>
<p><code>四次以上都可以，只不过 三次就够了</code></p>
<h4 id="四次挥手">四次挥手</h4>
<ul>
<li>一开始都处于 ESTABLISH 状态，然后客户端发送 FIN 报文，带上 seq = p，状态变为 FIN-WAIT-1</li>
<li>服务端收到之后，发送 ACK 确认，ack = p + 1，然后进入 CLOSE-WAIT 状态</li>
<li>客户端收到之后进入 FIN-WAIT-2  状态</li>
<li>过了一会等数据处理完，再次发送 FIN、ACK，seq = q，ack = p + 1，进入 LAST-ACK 阶段</li>
<li>客户端收到 FIN 之后，客户端收到之后进入 TIME_WAIT（等待 2MSL），然后发送 ACK 给服务端 ack = 1 + 1</li>
<li>服务端收到之后进入 CLOSED 状态</li>
</ul>
<p>客户端这个时候还需要等待两次 MSL 之后，如果没有收到服务端的重发请求，就表明 ACK 成功到达，挥手结束，客户端变为 CLOSED 状态，否则进行 ACK 重发</p>
<h4 id="为什么需要等待-2mslmaximum-segement-lifetime">为什么需要等待 2MSL（Maximum Segement Lifetime）：</h4>
<p>因为如果不等待的话，如果服务端还有很多数据包要给客户端发，且此时客户端端口被新应用占据，那么就会接收到无用的数据包，造成数据包混乱，所以说最保险的方法就是等服务器发来的数据包都死翘翘了再启动新应用。</p>
<ul>
<li>1个 MSL 保证四次挥手中主动关闭方最后的 ACK 报文能最终到达对端</li>
<li>1个 MSL 保证对端没有收到 ACK 那么进行重传的 FIN 报文能够到达</li>
</ul>
<h4 id="为什么是四次而不是三次">为什么是四次而不是三次？</h4>
<p>如果是三次的话，那么服务端的 ACK 和 FIN 合成一个挥手，那么长时间的延迟可能让 TCP 一位 FIN 没有达到服务器端，然后让客户的不断的重发 FIN</p>
<h4 id="参考资料">参考资料</h4>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/86426969">https://zhuanlan.zhihu.com/p/86426969</a></li>
<li><a href="https://juejin.cn/post/6844904070889603085">https://juejin.cn/post/6844904070889603085</a></li>
</ul>
<h2 id="n-转载源">n. 转载源</h2>
<ul>
<li><a href="https://juejin.cn/post/6939691851746279437">juejin-图雀社区-字节跳动最爱考的前端面试题：计算机网络基础</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MacOS 下使用nvm管理node环境]]></title>
        <id>https://stardemo.github.io/post/macos-xia-shi-yong-nvm-guan-li-node-huan-jing/</id>
        <link href="https://stardemo.github.io/post/macos-xia-shi-yong-nvm-guan-li-node-huan-jing/">
        </link>
        <updated>2021-04-13T02:34:06.000Z</updated>
        <summary type="html"><![CDATA[<p>node版本变化有些快，需要切换不同版本构建项目，使用nvm管理node是一个比较成熟的方案。</p>
]]></summary>
        <content type="html"><![CDATA[<p>node版本变化有些快，需要切换不同版本构建项目，使用nvm管理node是一个比较成熟的方案。</p>
<!-- more -->
<h2 id="1-安装nvm">1. 安装nvm</h2>
<h3 id="11-macos">1.1 MacOS</h3>
<ul>
<li>brew安装</li>
</ul>
<pre><code class="language-shell">brew install nvm 
</code></pre>
<ul>
<li>官方脚本</li>
</ul>
<pre><code class="language-shell">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
</code></pre>
<h3 id="12-linux">1.2 Linux</h3>
<pre><code class="language-shell">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
</code></pre>
<h3 id="13-安装注意事项">1.3 安装注意事项</h3>
<pre><code>==&gt; Caveats
Please note that upstream has asked us to make explicit managing
nvm via Homebrew is unsupported by them and you should check any
problems against the standard nvm install method prior to reporting.

You should create NVM's working directory if it doesn't exist:

  mkdir ~/.nvm

Add the following to ~/.zshrc or your desired shell
configuration file:

  export NVM_DIR=&quot;$HOME/.nvm&quot;
  [ -s &quot;/opt/homebrew/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/nvm.sh&quot;  # This loads nvm
  [ -s &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot;  # This loads nvm bash_completion

You can set $NVM_DIR to any location, but leaving it unchanged from
/opt/homebrew/opt/nvm will destroy any nvm-installed Node installations
upon upgrade/reinstall.

Type `nvm help` for further information.

</code></pre>
<ul>
<li>创建nvm目录</li>
</ul>
<pre><code class="language-shell">mkdir ~/.nvm
</code></pre>
<ul>
<li>处理<code>~/.zshrc</code>或者<code>~/.bashrc</code>（此处zsh举例）</li>
</ul>
<pre><code class="language-shell">  export NVM_DIR=&quot;$HOME/.nvm&quot;
  [ -s &quot;/opt/homebrew/opt/nvm/nvm.sh&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/nvm.sh&quot;  # This loads nvm
  [ -s &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot; ] &amp;&amp; . &quot;/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm&quot;  # This loads nvm bash_completion
</code></pre>
<h2 id="2-配置镜像加速">2. 配置镜像加速</h2>
<h3 id="21-nvm加速">2.1 nvm加速</h3>
<p>需要设置环境变量<code>NVM_NODEJS_ORG_MIRROR</code></p>
<pre><code class="language-shell"># 临时设置
export NVM_NODEJS_ORG_MIRROR=http://npm.taobao.org/mirrors/node
# 配置上述命令到bashrc/zshrc中保持生效
</code></pre>
<h3 id="22-npm加速">2.2 npm加速</h3>
<pre><code class="language-shell"># 查看当前registry
npm config -g get registry
# 设置registry
npm config -g set registry https://registry.npm.taobao.org
</code></pre>
<h3 id="23-yarn配置">2.3 yarn配置</h3>
<pre><code class="language-shell"># 安装yarn
npm install -g yarn
# 查看yarn registry
yarn config get registry
# 设置yarn registry
yarn config set registry http://registry.npm.taobao.org/
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Git HTTP+SSH 代理配置]]></title>
        <id>https://stardemo.github.io/post/git-httpssh-dai-li-pei-zhi/</id>
        <link href="https://stardemo.github.io/post/git-httpssh-dai-li-pei-zhi/">
        </link>
        <updated>2021-04-07T15:57:20.000Z</updated>
        <summary type="html"><![CDATA[<p>github访问日益困难,配置git服务代理以快速clone代码🐶</p>
]]></summary>
        <content type="html"><![CDATA[<p>github访问日益困难,配置git服务代理以快速clone代码🐶</p>
<!-- more -->
<p><em><strong>技术方案转载于<a href="http://www.chenhe.cc/p/406">http://www.chenhe.cc/p/406</a></strong></em></p>
<h2 id="http-代理">HTTP 代理</h2>
<h3 id="配置全局代理">配置全局代理</h3>
<pre><code class="language-shell"># HTTP 代理
git config --global http.proxy http://127.0.0.1:7890
git config --global https.proxy http://127.0.0.1:7890

# Socks5 代理
git config --global http.proxy socks5://127.0.0.1:7890
git config --global https.proxy socks5://127.0.0.1:7890
</code></pre>
<p>注意这里的<code>socks5</code>仅仅是代理使用的协议，它依然是针对 http 设置的，所以仅对 http 协议的仓库有效。使用 <code>git@xxx</code>这种 ssh 连接的不会使用代理。</p>
<h3 id="分域名设置代理">分域名设置代理</h3>
<pre><code class="language-shell">git config --global http.https://github.com.proxy http://127.0.0.1:7890
git config --global https.https://github.com.proxy https://127.0.0.1:7890
</code></pre>
<h2 id="ssh-代理">SSH 代理</h2>
<p>SSH 代理需要在密钥目录 (<code>~/.ssh</code>) (Windows 下是 <code>C:\Users\{UserName}\.ssh</code>) 新建一个 config 文件，没有后缀名。</p>
<h3 id="linuxmacos-系统写入以下配置">Linux/MacOS 系统写入以下配置：</h3>
<pre><code class="language-shell"># 需要 netcat
Host github.com
  User git
  Port 22
  Hostname github.com
  TCPKeepAlive yes
  ProxyCommand nc -v -x 127.0.0.1:1080 %h %p
</code></pre>
<h3 id="windows系统配置">Windows系统配置</h3>
<p>需要额外安装<code>connect.exe</code>程序,如果找不到 connect 命令那么指定其绝对路径，一般在 git 安装目录下 \mingw64\bin\connect.exe。</p>
<pre><code class="language-shell">Host github.com
  User git
  Port 22
  Hostname github.com
  TCPKeepAlive yes
  # -S 为 socks, -H 为 HTTP
  ProxyCommand connect -S 127.0.0.1:1080 %h %p
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux下使用curl查看http请求各阶段耗时]]></title>
        <id>https://stardemo.github.io/post/linux-xia-shi-yong-curl-cha-kan-http-qing-qiu-ge-jie-duan-hao-shi/</id>
        <link href="https://stardemo.github.io/post/linux-xia-shi-yong-curl-cha-kan-http-qing-qiu-ge-jie-duan-hao-shi/">
        </link>
        <updated>2021-04-07T15:50:42.000Z</updated>
        <summary type="html"><![CDATA[<p>HTTP接口在业务中速度较慢，使用curl进行排查</p>
]]></summary>
        <content type="html"><![CDATA[<p>HTTP接口在业务中速度较慢，使用curl进行排查</p>
<!-- more -->
<h2 id="1-准备文件模版curltxt">1. 准备文件模版（curl.txt）</h2>
<pre><code class="language-shell">\n
            time_namelookup:  %{time_namelookup}\n
               time_connect:  %{time_connect}\n
            time_appconnect:  %{time_appconnect}\n
           time_pretransfer:  %{time_pretransfer}\n
              time_redirect:  %{time_redirect}\n
         time_starttransfer:  %{time_starttransfer}\n
                            ----------\n
                 time_total:  %{time_total}\n
\n
</code></pre>
<h2 id="2-使用curl带以下参数请求">2. 使用curl带以下参数请求</h2>
<pre><code class="language-shell">curl -w &quot;@curl.txt&quot; -o /dev/null -s https://api.example.com
</code></pre>
<p>结果</p>
<pre><code>[@ ~]# curl -w &quot;@curl&quot; -o /dev/null -s https://api.example.com

            time_namelookup:  0.004
               time_connect:  0.014
            time_appconnect:  0.141
           time_pretransfer:  0.141
              time_redirect:  0.000
         time_starttransfer:  0.153
                            ----------
                 time_total:  0.165
</code></pre>
<h2 id="3-参数说明">3. 参数说明</h2>
<ul>
<li>NAMELOOKUP：从开始计算，域名解析完成的耗时</li>
</ul>
<p>CURLINFO_NAMELOOKUP_TIME. The time it took from the start until the name resolving was completed.</p>
<ul>
<li>CONNECT：从开始计算，TCP建立完成的耗时</li>
</ul>
<p>CURLINFO_CONNECT_TIME. The time it took from the start until the connect to the remote host (or proxy) was completed.</p>
<ul>
<li>APPCONNECT：从开始计算，应用层（SSL，在TCP之上的应用层）连接/握手完成的耗时</li>
</ul>
<p>CURLINFO_APPCONNECT_TIME. The time it took from the start until the SSL connect/handshake with the remote host was completed. (Added in in 7.19.0)</p>
<ul>
<li>PRETRANSFER：从开始计算，准备开始传输数据的耗时</li>
</ul>
<p>CURLINFO_PRETRANSFER_TIME. The time it took from the start until the file transfer is just about to begin. This includes all pre-transfer commands and negotiations that are specific to the particular protocol(s) involved.</p>
<ul>
<li>STARTTRANSFER：从开始计算，开始传输数据的耗时（libcurl接收到第一个字节）</li>
</ul>
<p>CURLINFO_STARTTRANSFER_TIME. The time it took from the start until the first byte is received by libcurl.</p>
<ul>
<li>TOTAL：总的耗时</li>
</ul>
<p>CURLINFO_TOTAL_TIME. Total time of the previous request.</p>
<ul>
<li>REDIRECT：整个过程重定向的耗时，如果整个过程没有重定向，这个时间为0</li>
</ul>
<p><em><strong>文章来源于互联网,原地址<a href="https://www.cnblogs.com/lnlvinso/p/9775484.html">https://www.cnblogs.com/lnlvinso/p/9775484.html</a></strong></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[在macOS下启用CGO_ENABLED的交叉编译]]></title>
        <id>https://stardemo.github.io/post/zai-macos-xia-qi-yong-cgo_enabled-de-jiao-cha-bian-yi/</id>
        <link href="https://stardemo.github.io/post/zai-macos-xia-qi-yong-cgo_enabled-de-jiao-cha-bian-yi/">
        </link>
        <updated>2021-03-26T12:15:00.000Z</updated>
        <summary type="html"><![CDATA[<p>go 启用CGO_ENABLED遇到报错的解决方案<br>
<code>gcc_libinit_windows.c:7:10: fatal error: 'windows.h' file not found</code></p>
]]></summary>
        <content type="html"><![CDATA[<p>go 启用CGO_ENABLED遇到报错的解决方案<br>
<code>gcc_libinit_windows.c:7:10: fatal error: 'windows.h' file not found</code></p>
<!-- more -->
<h2 id="在macos下启用cgo_enabled的交叉编译">在macOS下启用CGO_ENABLED的交叉编译</h2>
<p>在启用CGO_ENABLED的情况下，尝试使用下面命令进行Windows平台的交叉编译：</p>
<pre><code class="language-shell">$ CGO_ENABLED=1 GOOS=windows GOARCH=386 go build -x -v -ldflags &quot;-s -w&quot;
</code></pre>
<p>出现错误如下：</p>
<pre><code class="language-shell"># runtime/cgo
gcc_libinit_windows.c:7:10: fatal error: 'windows.h' file not found
</code></pre>
<h2 id="安装mingw-w64">安装mingw-w64</h2>
<pre><code class="language-shell">$ brew install mingw-w64
==&gt; Downloading https://homebrew.bintray.com/bottles/isl-0.22.1.big_sur.bottle.tar.gz
==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/15376fb7aff7adec3786e6a31ec9b5cad585fd01ecbd5c4744ef9461b10965ff?response-content-disposition=attachment%3Bfilename%3D%22isl-0.22.1.big_sur.bottle.tar.gz%22&amp;Policy=eyJTdGF0Z
######################################################################## 100.0%
==&gt; Downloading https://homebrew.bintray.com/bottles/mpfr-4.1.0.big_sur.bottle.tar.gz
==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/1e8eb0326f62d3461d420d98af6fc088daca481cae89fd77a75b420d2e76d776?response-content-disposition=attachment%3Bfilename%3D%22mpfr-4.1.0.big_sur.bottle.tar.gz%22&amp;Policy=eyJTdGF0Z
######################################################################## 100.0%
==&gt; Downloading https://homebrew.bintray.com/bottles/libmpc-1.2.1.big_sur.bottle.tar.gz
######################################################################## 100.0%
==&gt; Downloading https://homebrew.bintray.com/bottles/mingw-w64-8.0.0.catalina.bottle.tar.gz
==&gt; Downloading from https://d29vzk4ow07wi7.cloudfront.net/d294bc0e960294bf573b9da364a8d95a06a257aec8f388c16e2b975ed8e4410c?response-content-disposition=attachment%3Bfilename%3D%22mingw-w64-8.0.0.catalina.bottle.tar.gz%22&amp;Policy=eyJ
######################################################################## 100.0%
==&gt; Installing dependencies for mingw-w64: isl, mpfr and libmpc
==&gt; Installing mingw-w64 dependency: isl
==&gt; Pouring isl-0.22.1.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/isl/0.22.1: 72 files, 4.9MB
==&gt; Installing mingw-w64 dependency: mpfr
==&gt; Pouring mpfr-4.1.0.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/mpfr/4.1.0: 30 files, 5.2MB
==&gt; Installing mingw-w64 dependency: libmpc
==&gt; Pouring libmpc-1.2.1.big_sur.bottle.tar.gz
🍺  /usr/local/Cellar/libmpc/1.2.1: 13 files, 425.0KB
==&gt; Installing mingw-w64
==&gt; Pouring mingw-w64-8.0.0.catalina.bottle.tar.gz
🍺  /usr/local/Cellar/mingw-w64/8.0.0: 7,402 files, 854.6MB
$ which x86_64-w64-mingw32-gcc
/usr/local/bin/x86_64-w64-mingw32-gcc
</code></pre>
<h2 id="编译x64">编译x64</h2>
<h3 id="可执行文件">可执行文件</h3>
<pre><code class="language-shell">$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -x -v -ldflags &quot;-s -w&quot; -o app.exe
</code></pre>
<h3 id="静态库">静态库</h3>
<pre><code class="language-shell">$ CGO_ENABLED=1 CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ GOOS=windows GOARCH=amd64 go build -buildmode=c-archive -x -v -ldflags &quot;-s -w&quot; -o bin app.go
</code></pre>
<h3 id="动态库">动态库</h3>
<p>将<code>-buildmode=c-archive</code>改为<code>-buildmode=c-shared</code>即可</p>
<p><em><strong>转载资料 出处:<a href="https://www.dllhook.com/post/244.html">https://www.dllhook.com/post/244.html</a></strong></em></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kubernetes暴露信息给Pod]]></title>
        <id>https://stardemo.github.io/post/kubernetes-bao-lu-xin-xi-gei-pod/</id>
        <link href="https://stardemo.github.io/post/kubernetes-bao-lu-xin-xi-gei-pod/">
        </link>
        <updated>2021-02-06T08:53:01.000Z</updated>
        <content type="html"><![CDATA[<h3 id="capabilities-of-the-downward-api">Capabilities of the Downward API</h3>
<h4 id="feildref即可以暴露的pod定义中的项目">feildRef，即可以暴露的pod定义中的项目：</h4>
<pre><code>spec.nodeName - the node’s name
status.hostIP - the node’s IP
metadata.name - the pod’s name
metadata.namespace - the pod’s namespace
status.podIP - the pod’s IP address
spec.serviceAccountName - the pod’s service account name
metadata.uid - the pod’s UID
metadata.labels['&lt;KEY&gt;'] - the value of the pod’s label &lt;KEY&gt; (for example, metadata.labels['mylabel']); available in Kubernetes 1.9+
metadata.annotations['&lt;KEY&gt;'] - the value of the pod’s annotation &lt;KEY&gt; (for example, metadata.annotations['myannotation']); available in Kubernetes 1.9+
</code></pre>
<h4 id="resourcefieldref即可以暴露的container定义中的项目">resourceFieldRef，即可以暴露的container定义中的项目：</h4>
<ul>
<li>A Container’s CPU limit</li>
<li>A Container’s CPU request</li>
<li>A Container’s memory limit</li>
<li>A Container’s memory request</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LDAP使用记录]]></title>
        <id>https://stardemo.github.io/post/ldap-shi-yong-ji-lu/</id>
        <link href="https://stardemo.github.io/post/ldap-shi-yong-ji-lu/">
        </link>
        <updated>2020-12-11T07:00:44.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h2 id="rancher访问ldap的默认规则">Rancher访问LDAP的默认规则</h2>
<h3 id="用户">用户</h3>
<pre><code>搜索起点: ou=Users,dc=thecover,dc=cn
对象分类: inetOrgPerson
登录字段: uid
名称字段: cn
搜索字段: uid|sn|givenName
启用字段:
禁用位掩码: 0
</code></pre>
<h3 id="用户组">用户组</h3>
<pre><code>搜索起点: ou=Groups,dc=thecover,dc=cn
对象分类: groupOfNames
名称字段: cn
搜索字段: cn
</code></pre>
<h3 id="创建只读用户">创建只读用户</h3>
<ul>
<li>创建用户（可以用管理工具创建同objectClass的用户）</li>
</ul>
<pre><code>#密码
LDAP_READONLY_USER_PW='密码'
#Base DN
LDAP_BASE_DN='dc=thecover,dc=cn'
cat &lt;&lt;EOF &gt; ./readOnly.ldif
dn: cn=readonly,${LDAP_BASE_DN}
cn: readonly
objectClass: simpleSecurityObject
objectClass: organizationalRole
description: LDAP read only user
userPassword: ${LDAP_READONLY_USER_PW}
EOF
</code></pre>
<p>命令行增加用户</p>
<pre><code>ldapadd -x -D cn=Manager,dc=okcoin,dc=com -w '密码' -f ./readOnly.ldif
</code></pre>
<ul>
<li>配置权限</li>
</ul>
<pre><code>LDAP_BASE_DN='dc=thecover,dc=cn'
cat &lt;&lt;EOF &gt; readonly-user-acl.ldif
dn: olcDatabase={1}hdb,cn=config
changetype: modify
delete: olcAccess
-
add: olcAccess
olcAccess: {0}to attrs=userPassword,shadowLastChange 
 by dn=&quot;cn=admin,dc=thecover,dc=cn&quot; write 
 by anonymous auth 
 by self write 
 by dn=&quot;cn=readonly,dc=thecover,dc=cn&quot; read 
 by * none
olcAccess: {1}to dn.base=&quot;&quot; by * read
olcAccess: {2}to * by dn=&quot;cn=Manager,dc=thecover,dc=cn&quot; write by * read
EOF
</code></pre>
<pre><code>ldapmodify -Y EXTERNAL -H ldapi:/// -f readonly-user-acl.ldif
</code></pre>
<ul>
<li>备注<br>
配置权限时需要使用</li>
</ul>
<pre><code>slapcat -b cn=config
</code></pre>
<p>定位<code>olcDatabase</code> <code>config</code>的位置</p>
<h2 id="ldap增加memberof属性">Ldap增加memberOf属性</h2>
<p>https://www.linuxprobe.com/enable-memberof-openldap.html<br>
https://kifarunix.com/how-to-create-openldap-member-groups/</p>
<h2 id="配置缓存">配置缓存</h2>
<h3 id="查询缓存配置">查询缓存配置</h3>
<pre><code class="language-shell">ldapsearch -Q -LLL -Y EXTERNAL -H ldapi:/// -b cn=config 'olcDatabase={0}mdb' olcDbindex
</code></pre>
<h3 id="删除旧配置">删除旧配置</h3>
<pre><code class="language-shell">cat &gt;&gt; del-1mdb-index.ldif &lt;&lt; EOF
dn: olcDatabase={1}mdb, cn=config
changetype:modify
delete: olcDbIndex
olcDbIndex: uid eq
EOF
 ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f del-1mdb-index.ldif
</code></pre>
<h3 id="新增配置">新增配置</h3>
<pre><code class="language-shell">cat &gt;&gt; mdb-index.ldif &lt;&lt; EOF
dn: olcDatabase={1}mdb, cn=config
changetype:modify
add:olcDbIndex
olcDbIndex: uid pres,eq,sub
EOF
ldapmodify -Q -Y EXTERNAL -H ldapi:/// -f mdb-index.ldif
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[阿里云K8s实践笔记]]></title>
        <id>https://stardemo.github.io/post/a-li-yun-k8s-zui-jia-shi-jian-bi-ji/</id>
        <link href="https://stardemo.github.io/post/a-li-yun-k8s-zui-jia-shi-jian-bi-ji/">
        </link>
        <updated>2020-09-16T03:36:16.000Z</updated>
        <summary type="html"><![CDATA[<p>记录使用阿里云ACK容器服务以及阿里云的各服务的总结笔记</p>
]]></summary>
        <content type="html"><![CDATA[<p>记录使用阿里云ACK容器服务以及阿里云的各服务的总结笔记</p>
<!-- more -->
<h2 id="1-配置阿里云slb到集群的ingress">1. 配置阿里云SLB到集群的Ingress</h2>
<h3 id="11-同时使用私网slb与公网slb配合">1.1 同时使用私网SLB与公网SLB配合</h3>
<p><em>对于一些特殊场景，您期望容器集群内的服务既能允许公网访问，同时又希望能被同一个VPC下的其他服务直接访问（不经过公网）。您只需额外部署一个kube-system/nginx-ingress-lb-intranet服务。</em></p>
<p>使用阿里云创建的容器集群默认已经创建了一个绑定到公网的SLB，位于<code>kube-system</code>下。创建一个符合期望配置的内网SLB实例，新增一个Service描述，使集群自动绑定监听到SLB。</p>
<p>配置模版</p>
<pre><code class="language-yaml"># intranet nginx ingress slb service
apiVersion: v1
kind: Service
metadata:
 # 这里服务取名为nginx-ingress-lb-intranet
 name: nginx-ingress-lb-intranet
 namespace: kube-system
 labels:
   app: nginx-ingress-lb-intranet
 annotations:
   # 指明SLB实例地址类型为私网类型
   service.beta.kubernetes.io/alicloud-loadbalancer-address-type: intranet
   # 修改为您的私网SLB实例ID
   service.beta.kubernetes.io/alicloud-loadbalancer-id: &lt;YOUR_INTRANET_SLB_ID&gt;
   # 是否自动创建SLB端口监听（会覆写已有端口监听），也可手动创建端口监听
   service.beta.kubernetes.io/alicloud-loadbalancer-force-override-listeners: 'true'
spec:
 type: LoadBalancer
 # route traffic to other nodes
 externalTrafficPolicy: &quot;Cluster&quot;
 ports:
 - port: 80
   name: http
   targetPort: 80
 - port: 443
   name: https
   targetPort: 443
 selector:
   # select app=ingress-nginx pods
   app: ingress-nginx
</code></pre>
<p>创建服务之后通过如下命令,查看svc状态</p>
<pre><code class="language-shell"> kubectl -n kube-system get svc | grep nginx-ingress-lb
</code></pre>
<h2 id="2-coredns的特殊用法">2. CoreDNS的特殊用法</h2>
<h3 id="21-coredns拦截域名解析">2.1 CoreDNS拦截域名解析</h3>
<p>在内网多个集群的场景下，有些域名需要解析到内网避免出现公网流量，之前处理方案有如下几种:</p>
<ul>
<li>在VPC内网内自建一个DNS服务器，将所有服务器的DNS指向自建的DNS服务器
<ul>
<li>问题: 需要考虑到DNS的高可用以及故障容灾难</li>
<li>优势: 集中化,便于统一维护管理更新</li>
</ul>
</li>
<li>在主机配置Hosts文件
<ul>
<li>问题: 主机较多，维护成本上涨</li>
<li>优势: 操作简单，技术成本较低</li>
</ul>
</li>
<li>K8s容器集群内CoreDNS</li>
</ul>
<p>Kubernetes本身具有集群DNS组件，此处使用的为CoreDNS，工作负载的DNS默认策略为<code>ClusterFirst</code>,此时Pods内程序解析DNS会优先查询集群的DNS组件，所以此时可以在集群DNS层面进行解析拦截覆盖。</p>
<p>CoreDNS的配置使用的ConfigMap,而ConfigMap支持热更新,修改ConfigMap后CoreDNS自动生效。配置如下:</p>
<pre><code>.:5353 {
cache 30
errors
health
kubernetes cluster.local in-addr.arpa ip6.arpa {
pods insecure
upstream /etc/resolv.conf
fallthrough in-addr.arpa ip6.arpa
}
loadbalance round_robin
hosts {
122.212.222.111 aaa.bbb.com
fallthrough
}
prometheus 0.0.0.0:9153
proxy . /etc/resolv.conf
reload
}
</code></pre>
<p>把需要的DNS规格写入Hosts节点下，即可进行集群层面的解析配置。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用nc检测TCP/UDP端口开放]]></title>
        <id>https://stardemo.github.io/post/shi-yong-nc-jian-ce-tcpudp-duan-kou-kai-fang/</id>
        <link href="https://stardemo.github.io/post/shi-yong-nc-jian-ce-tcpudp-duan-kou-kai-fang/">
        </link>
        <updated>2020-08-18T13:40:09.000Z</updated>
        <content type="html"><![CDATA[<h1 id="telnet-检测tcp端口">Telnet 检测TCP端口</h1>
<pre><code class="language-shell">[root@localhost ~]# telnet 127.0.0.1 8080
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
^CConnection closed by foreign host.
</code></pre>
<h1 id="nc-检测tcp端口">NC 检测TCP端口</h1>
<pre><code class="language-shell">[root@localhost ~]# nc -vz 127.0.0.1 8906
Connection to 127.0.0.1 8906 port [tcp/*] succeeded!
</code></pre>
<h1 id="nc-检测udp端口">NC 检测UDP端口</h1>
<p><code>检测udp端口的时候不会立即返回测试结果，可能需要等待几秒钟</code></p>
<pre><code class="language-shell">[root@apexsoft ~]# nc -uz 127.0.0.1 8907
Connection to 127.0.0.1 8907 port [udp/*] succeeded!
</code></pre>
]]></content>
    </entry>
</feed>